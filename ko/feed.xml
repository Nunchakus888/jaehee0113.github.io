<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.3.1">Jekyll</generator><link href="/ko/feed.xml" rel="self" type="application/atom+xml" /><link href="/ko/" rel="alternate" type="text/html" /><updated>2017-07-31T22:46:43+10:00</updated><id>http://localhost:4000/</id><title type="html">Jae Hee Lee</title><subtitle>Philsensus's Blog.
</subtitle><entry><title type="html">how to use grep</title><link href="/ko/posts/how-to-use-grep" rel="alternate" type="text/html" title="how to use grep" /><published>2017-05-05T00:00:00+10:00</published><updated>2017-05-05T00:00:00+10:00</updated><id>http://localhost:4000/posts/how-to-use-grep</id><content type="html" xml:base="http://localhost:4000/posts/how-to-use-grep">&lt;pre&gt;
  &lt;code&gt; Unix 기반의 시스템의 설명입니다 &lt;/code&gt;
&lt;/pre&gt;

&lt;h1&gt; 배경 &lt;/h1&gt;

&lt;p&gt;Unix 기반 환경에서 server troubleshooting을 할 때 가장 기본적으로 쓰이는 명령어 중에 하나이다. grep 은 “&lt;b&gt;g&lt;/b&gt;lobal search for &lt;b&gt;re&lt;/b&gt;gular expression and &lt;b&gt;p&lt;/b&gt;rint all lines containing it” 의 약자라고 생각하면 되겠다. 억지라고 생각하면 그렇지만 사실 읽기 쉽지 않은가? 그랩! 말그대로 grab (갖고 오다) 라가 연상되는 명령어로써 참 직관적이라고 생각한다.&lt;/p&gt;

&lt;p&gt;Grep과 함께 pipeline 컨셉을 이해하여야 한다. 이 건, 단순히 여기서만 나오는게 아니라 대부분의 프로그래밍 언어에서도 항상 쓴다. 그러니 나중을 위해 꼭 이해하고 있도록 하자.&lt;/p&gt;

&lt;h1&gt; Pipe (또는 Pipeline) &lt;/h1&gt;

&lt;p&gt;Pipe 는 &lt;b&gt;|&lt;/b&gt; 기호를 쓴다. 이 기호는 } 키 옆에 있는 (Shift 누르고) 그 키이다. Pipe의 기본 개념은 명령어 들을 체인처럼 연결하는 것이다. 예를들어 &lt;b&gt; 명령어1 | 명령어2 면&lt;/b&gt; “명령어1를 실행 후 그것의 결과를 다시 명령어2의 input로 생각해 명령어2를 실행하고 결과를 나에게 보여주세요” 정도의 의미라고 생각하면 되겠다.&lt;/p&gt;

&lt;p&gt;간단한 예제를 들어보자:&lt;/p&gt;

&lt;pre&gt;
  &lt;code&gt; $ ls -la | grep gro &lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;를 실행하면, gro 가 포함된 파일 또는 폴더를 자세하게 리스트로 출력하시오. 의 의미정도가 되겠다. 참고로 -la는 l (long format) 과 a (all) 의 합성 코맨드가 되겠다 (즉 la 나 al 다 똑같음).&lt;/p&gt;

&lt;p&gt;그러면 gro 가 포함된 모든 파일의 긴 리스트가 나온다.&lt;/p&gt;

&lt;h1&gt; grep options &lt;/h1&gt;

&lt;p&gt;Grep 명령어를 실행할 때 다음과 같은 옵션을 고려할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt; -i : case insentitive &lt;/li&gt;
  &lt;li&gt; -c : number of matches &lt;/li&gt;
  &lt;li&gt; -n : line number 까지 출력 &lt;/li&gt;
  &lt;li&gt; -v : match 안된 것 까지 다 출력 &lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt; sort &lt;/h1&gt;

&lt;p&gt;결과물의 리스트를 정렬할 수 있다. 다음과 같은 option을 사용할 수 있다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt; -r : reversed sort &lt;/li&gt;
  &lt;li&gt; -n : numerical sort &lt;/li&gt;
  &lt;li&gt; -f : upper and lowercase sort &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 외에도 너무나 많다. 아주 기본적인 내용만 담았고 더 자세하게 알려면 구글에서 documentation을 살펴보시길.&lt;/p&gt;</content><author><name></name></author><summary type="html">Unix 기반의 시스템의 설명입니다</summary></entry><entry><title type="html">Understanding UNIX User Group file</title><link href="/ko/posts/etc-group-file" rel="alternate" type="text/html" title="Understanding UNIX User Group file" /><published>2017-05-05T00:00:00+10:00</published><updated>2017-05-05T00:00:00+10:00</updated><id>http://localhost:4000/posts/etc-group-file</id><content type="html" xml:base="http://localhost:4000/posts/etc-group-file">&lt;pre&gt;
  &lt;code&gt; Unix 기반의 시스템의 설명입니다 &lt;/code&gt;
&lt;/pre&gt;

&lt;h1&gt; 배경 &lt;/h1&gt;

&lt;p&gt;지난에 chmod 명령어를 공부하면서 그룹중에 Group이 있다고 하였고, 그 그룹을 정의하는 파일이 &lt;code&gt; etc/group &lt;/code&gt; 이라고 하였다. 이번에 이 파일의 syntax를 살펴보고자 한다.&lt;/p&gt;

&lt;p&gt;일단 이 파일을 열어보면 다음과 같은 내용이 있을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ec2-user:x:500:&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;도대체 이 것이 무엇을 의미하는 것일까?&lt;/p&gt;

&lt;h1&gt; Syntax &lt;/h1&gt;

&lt;p&gt;각 줄에는 다음과 같은 syntax를 따른다:&lt;/p&gt;

&lt;pre&gt;
  &lt;code&gt; 그룹이름:비밀번호:GID:유저리스트&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt; 그룹이름: 말 그대로 그룹의 이름이다. &lt;/li&gt;
  &lt;li&gt; 비밀번호: 그룹 패스워드이다. 만약 비어있으면 패스워드가 필요없다는 의미이다. 그러나 * 또는 x 로 대체되기도 한다. &lt;/li&gt;
  &lt;li&gt; GID: 숫자 (numerical) 로 이루어진 그룹의 ID이다. &lt;/li&gt;
  &lt;li&gt; 유저리스트: 이 그룹에 속해 있는 유저의 리스트이다. 각 유저는 &lt;b&gt;, (콤마)&lt;/b&gt;로 구분된다. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러면 다음을 해석해보자:&lt;/p&gt;

&lt;pre&gt;
  &lt;code&gt; cool_users:x:583:jae,pae&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;cool_users 그룹 (ID는 583) 은 비밀번호가 필요없고 현재 jae 와 pae 유저가 속해있다.&lt;/p&gt;</content><author><name></name></author><summary type="html">Unix 기반의 시스템의 설명입니다</summary></entry><entry><title type="html">Understanding chmod / chown / chgrp</title><link href="/ko/posts/general/chmod" rel="alternate" type="text/html" title="Understanding chmod / chown / chgrp" /><published>2017-05-05T00:00:00+10:00</published><updated>2017-05-05T00:00:00+10:00</updated><id>http://localhost:4000/posts/general/chmod</id><content type="html" xml:base="http://localhost:4000/posts/general/chmod">&lt;pre&gt;
  &lt;code&gt; Unix 기반의 시스템의 설명입니다 &lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;가끔 server troubleshooting을 할 때 보면 folder 또는 file permission 이 원인인 문제가 있다. 이 때, permission을 변경해 주어야 하는데, 그때 사용하는 명령어가 chmod (change mode의 준말) 이다.&lt;/p&gt;

&lt;p&gt;보통 이 것을 보기 위해서는 ls 대신 ls -la 를 해야 파일 또는 폴더의 권한을 제대로 볼 수 있는데, 처음하는 사람들은 그냥 chmod 777 만 알거나 더 알면 -R (apply recursively) 까지 아는 수준일 가능성이 높다. 이번에는 제대로 chmod 에 대해서 알아보자.&lt;/p&gt;

&lt;h1&gt; Binary 의 이해 &lt;/h1&gt;

&lt;p&gt;자 일단, 각 권한은 3개의 그룹으로 이루어진 3 bits로 이루어져 있다. 그래서 777은 각 그룹의 권한이고 이 3개의 그룹의 권한을 정해주는 것이고, 이 권한의 경우 0-7 사이로 이루어 진다. 여기서 0 ~ 7은 decimal이고 이것을 binary로 표현하면 다음과 같다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt; 000 =&amp;gt; 0 &lt;/li&gt;
  &lt;li&gt; 001 =&amp;gt; 1 &lt;/li&gt;
  &lt;li&gt; 010 =&amp;gt; 2 &lt;/li&gt;
  &lt;li&gt; 011 =&amp;gt; 3 &lt;/li&gt;
  &lt;li&gt; 100 =&amp;gt; 4 &lt;/li&gt;
  &lt;li&gt; 101 =&amp;gt; 5 &lt;/li&gt;
  &lt;li&gt; 110 =&amp;gt; 6 &lt;/li&gt;
  &lt;li&gt; 111 =&amp;gt; 7 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;111의 경우를 보자: 첫번째  자리가 1일 경우 1 * 2^0 = 1 이고, 두번째 자리가 1일 경우 1 * 2^1 = 2 그리고 세번째 자리가 1일 경우 1 * 2^2 = 4 이므로 1 + 2 + 4 = 7 (decimal conversion) 이 된다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Q. 101 은 어떻게 되는가?&lt;/p&gt;
&lt;p&gt;A. (1 * 2^2) + (0 * 2^1) + (1 * 2^0) = 4 + 0 + 1 = 5 가 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt; Binary 자리의 의미 &lt;/h1&gt;

&lt;p&gt;저 binary value들이 상당히 중요하다. Boolean value 처럼 1은 True 이고 0은 False를 가정했을 때 (켜고 끄기). 각 자리는 다음과 같은 권한을 나타낸다&lt;/p&gt;

&lt;p&gt;&lt;code&gt; (Read) (Write) (Execute) &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;그래서 101 의 경우는 read and execute만 가능하게 하는 것이다!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Q. 111 은 어떻게 되는가?&lt;/p&gt;
&lt;p&gt;A. Read, Write, Execute 다 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt; 숫자대신 기호로 &lt;/h1&gt;

&lt;p&gt;하지만 ls -la 를 하게 되면 숫자로 권한을 보여주지 않는다. 기호로 보여주는데:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt; &lt;b&gt;Read (r)&lt;/b&gt;: 파일을 읽을 수 있다. 하지만, 파일의 이름을 알 수 있고 다른 정보들 (내용, 타입등) 은 알수가 없다.&lt;/li&gt;
  &lt;li&gt; &lt;b&gt;Write (w)&lt;/b&gt;: 파일을 수정할 수 있다. 폴더를 설정하게 되면, 파일들을 수정할 수 있다 (CRUD) &lt;/li&gt;
  &lt;li&gt; &lt;b&gt;Execute (x)&lt;/b&gt;: 파일을 실행할 권한을 준다. shell script나 실행 가능한 프로그램 (executable programs) 들을 실행할 권한이다. &lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt; 3개의 그룹 정의 &lt;/h1&gt;

&lt;p&gt;다음과 같은 순서로 3개의 그룹을 항상 정해 주어야 한다: Owner (소유자), Group (그룹), World (세계) 이다. 각 그룹들의 관계는 subset 관계이다. Owner ⊆ Group ⊆ World 이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt; &lt;b&gt;Owner&lt;/b&gt;: 말 그대로 소유자이다 (특정 유저). &lt;/li&gt;
  &lt;li&gt; &lt;b&gt;Group&lt;/b&gt;: Linux 에서는 유저들을 어떤 특정 Group에 속할 수 있게 해주는데, &lt;code&gt;etc/group&lt;/code&gt; 에서 확인 할 수 있다. 파일에 대한 설명은 나중에 하도록 하겠다. &lt;/li&gt;
  &lt;li&gt; &lt;b&gt;World&lt;/b&gt;: 모든 유저들의 권한이다.  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그래서 ls -la를 해보면 다음과 같은 내용을 얻을 수 있다:&lt;/p&gt;

&lt;pre&gt;
  &lt;code&gt; drwxrwxr-x root root 4088 Apr 21 04:10 .bashrc &lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;여기서 d의 의미는 directory 의 의미다. 즉 폴더란 얘기다.&lt;/p&gt;

&lt;blockquote&gt;
  첫번째 위치에 있는 것들을 special file designator라고 하는데, 보통 파일은 -로 표기된다. 이런것들이 있을 수 있다
  &lt;ul&gt;
    &lt;li&gt; d (directory) &lt;/li&gt;
    &lt;li&gt; c (character device) &lt;/li&gt;
    &lt;li&gt; s (socket) &lt;/li&gt;
    &lt;li&gt; p (named pipe) &lt;/li&gt;
    &lt;li&gt; l (symlink) &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;맨 앞에 나오는 내용을 보면 d를 제거하면 rwxrwxr-x인데, 3개씩 잘라보면 다음과 같은 의미가 된다 (그룹 순서가 여기서 중요한 것이다).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt; &lt;b&gt;Owner&lt;/b&gt;: rwx (다됨) &lt;/li&gt;
  &lt;li&gt; &lt;b&gt;Group&lt;/b&gt;: rwx (다됨) &lt;/li&gt;
  &lt;li&gt; &lt;b&gt;World&lt;/b&gt;: r-x (write가 되지 않는다) &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제보면 참 쉽다. 이것을 chmod를 한다고 하면 일단 다 되는건 111 111 일테고 중간이 안되니까 마지막은 101이겠다. 이제 이 것을 decimal으로 변환하면 7 7 그리고 5가 되겠다 그래서 이 것과 똑같은 권한으로 다른 파일이나 폴더의 권한을 변경하면, &lt;code&gt; chmod 775 -R (만약 recusively 하게 한다면) &lt;/code&gt; 가 되겠다.&lt;/p&gt;

&lt;h1&gt; 관련 명령어 &lt;/h1&gt;

&lt;h3&gt; chown (change owner) &lt;/h3&gt;

&lt;p&gt;말 그대로 Owner를 바꿔지는 명령어이다. 명령어는 다음과 같이 사용된다:&lt;/p&gt;

&lt;pre&gt;
  &lt;code&gt; $ chown [user] [file] &lt;/code&gt;
&lt;/pre&gt;

&lt;h3&gt; chgrp (change group) &lt;/h3&gt;

&lt;p&gt;파일의 Group owner를 바꿔주는 역할을 한다. 명령어는 다음과 같이 사용된다:&lt;/p&gt;

&lt;pre&gt;
  &lt;code&gt; $ chgrp [group name / GID] [file] &lt;/code&gt;
&lt;/pre&gt;</content><author><name></name></author><category term="general" /><summary type="html">Unix 기반의 시스템의 설명입니다</summary></entry><entry><title type="html">Amaysim Prepaid 후기</title><link href="/ko/posts/amaysim-prepaid-review" rel="alternate" type="text/html" title="Amaysim Prepaid 후기" /><published>2017-05-05T00:00:00+10:00</published><updated>2017-05-05T00:00:00+10:00</updated><id>http://localhost:4000/posts/amaysim-prepaid-review</id><content type="html" xml:base="http://localhost:4000/posts/amaysim-prepaid-review">&lt;pre&gt; Amaysim 하고 상관이 없는 사람입니다! &lt;/pre&gt;

&lt;p&gt;매달 $29 로 Unlimited 3GB 를 이용하고 있는데, 개인적으로 현재 내가 사용해본 통신사중에 최고로 저렴한데 좋은 deal이라고 생각한다.&lt;/p&gt;

&lt;p&gt;이유는 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt; 국제전화가 무료이다: unlimited 라 제한이 전혀 없다. &lt;/li&gt;
	&lt;li&gt; 국내전화가 무료이다 &lt;/li&gt;
	&lt;li&gt; 문자가 무료이다 &lt;/li&gt;
	&lt;li&gt; 4G 대부분의 지역에서 잘 터진다 &lt;/li&gt;
	&lt;li&gt; 아무래도 인터넷으로 모든 것을 해결할 수 있어 정말 간편하고 좋다. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;한국에 있는 친구들과 부모님께 물론 카톡으로도 할 수 있지만, 와이파이 없는 지역에서는 국제전화를 쓸 수 있어 너무나 유용하다. 단지 한국만이 아니다. 전세계 웬만한 국가들은 다 된다 (싱가포르, 미국 꽁짜인거 확인!)&lt;/p&gt;

&lt;p&gt;정말 이걸 쓰고 호주가 통신 선진국이라는 인상이 처음으로 강하게 들었다. 앞으로도 계속 쓸 것 같다!&lt;/p&gt;</content><author><name></name></author><summary type="html">Amaysim 하고 상관이 없는 사람입니다!</summary></entry><entry><title type="html">포스팅을 하는 이유</title><link href="/ko/posts/general/why-post" rel="alternate" type="text/html" title="포스팅을 하는 이유" /><published>2017-05-02T00:00:00+10:00</published><updated>2017-05-02T00:00:00+10:00</updated><id>http://localhost:4000/posts/general/why-post</id><content type="html" xml:base="http://localhost:4000/posts/general/why-post">&lt;h1&gt; 포스팅을 꺼리던 이유 &lt;/h1&gt;

&lt;p&gt;내가 포스팅을 꺼리던 이유가 있다. 첫번 째로, 사실이 아닐 수 있기 때문이다. 글을 쓸 때는 내 머리속에서 정리된 내용을 바탕으로 쓴다. 사실 확인 작업을 하려고 노력하지만, 완벽할 수 없기에, 사실 확인이 되지 않는다. 예를들어, 기술 관련 글을 쓸 때, 틀린 내용을 적을 수도 있다. 그렇게 되면, 극단적으로 얘기해서 그 사실이 아닌 정보를 누가 진실로 받아들여, 삶을 망칠 수도 있다는 생각을 하게 되어 주저하였다. 두번 째로, 항상 객관성을 유지할 수 없다. 쓰다보면 주관적인 내용도 포함하게 되는데, 주관적인 내용은 좋지 않다는 생각이 있었다.&lt;/p&gt;

&lt;p&gt;사실 글을 쓰는 이유는 나를 위한 것이다. 나중에 쓸만한 생각을 정리하는 것 그리고 내가 학습했던 내용을 정리하는 것인 목적이 크다. 하지만, 이왕 쓰는 거 다른 사람들도 볼수 있도록 공개하는 것이다.&lt;/p&gt;

&lt;h1&gt; 몇가지 기능으로 꺼리던 이유들을 보완 &lt;/h1&gt;

&lt;p&gt;다음과 같은 기능으로 위 문제점들을 보완하고자 한다. 첫번 째 문제점 해결방안은 commenting system 이다. 각 포스트마다 disqus 댓글 기능을 연동하여, 사실이 아닐 시, 충분히 이의제기를 하도록 해놓았다. 문제점이 있으면 확인 후 고치도록 하겠다. 그리고 두번 째 문제점도 댓글로 보완 가능하다. 주관적인 내용에 대해서 토론할 수 있도록 가능하게 하였다.&lt;/p&gt;

&lt;p&gt;고치는 부분에 대해, Jekyll은 내가 완전히 컨트롤 할 수 있게 해주는 블로그 이다. 그래서 고치는 것에 대해 자유롭다.&lt;/p&gt;

&lt;p&gt;또한 협업자 중에 Txtpen이라는 기능 (말 그대로 어떤 문구를 highlight 하여 자신의 google account에 저장하는 기능) 으로 객관적인 내용만 따로 정리할 수 있도록 기능을 추가하였다.&lt;/p&gt;

&lt;p&gt;직접 대화하고 싶다면 내가 허락하는 범위 내의 social media를 통해 충분히 연락가능 하다.&lt;/p&gt;

&lt;h1&gt; 나의 경험이 사람들에게 도움 될수도 &lt;/h1&gt;

&lt;p&gt;살아오면서 사람들은 (나 포함) 다른 사람의 경험담이 영향을 주는 것 같다. 영향의 정도의 차이가 문제지 남의 경험담은 객관성 있는 부분만 추려낸다면 충분히 도움이 될 수 있다고 생각한다. 예를들어 개발 분야에서는 stackoverflow 등 개발자 커뮤니티가 활성화 되어있다. 개발 시 어떤 문제점이 발생 했을 때, stackoverflow에서 질문을 하거나 문답이 이미 있는 글들을 항상 참조하여 개발을 한다 (이거 안하는 개발자 1명도 없을 것이다). 이 것도 남의 노하우를 내 일에 적용하는 것이다. 내가 올린 버젼 관리 포스팅들도 많은 개발자들이 오랜 시간 거쳐서 얻어낸 중요한 결론을 꽁짜? 로 습득한 내용들이다. 물론 문제점이 있겠지만, 요즘같이 새로운 지식을 빨리 습득해야 되는 시대에서는 상당히 중요하다고 생각한다.&lt;/p&gt;

&lt;p&gt;그래서 나도 내 경험을 공유하고 싶다. 내가 무료로 그들의 경험에서 도움을 받은 것 처럼 말이다. 열심히 하려고 노력하고 있고 또한 최대한 객관성을 유지하려고 노력하고 있다.&lt;/p&gt;

&lt;p&gt;다만 가끔 잡소리를 할 때가 있을 텐데 그건 좀 이해해 주시길.. 부탁드린다.&lt;/p&gt;</content><author><name></name></author><category term="general" /><summary type="html">포스팅을 꺼리던 이유</summary></entry><entry><title type="html">Vim의 필요성</title><link href="/ko/posts/general/why-vim" rel="alternate" type="text/html" title="Vim의 필요성" /><published>2017-05-01T00:00:00+10:00</published><updated>2017-05-01T00:00:00+10:00</updated><id>http://localhost:4000/posts/general/why-vim</id><content type="html" xml:base="http://localhost:4000/posts/general/why-vim">&lt;pre&gt; &lt;b&gt; 이 페이지는 지원되는 모든 언어로 번역되어 있습니다.&lt;/b&gt; &lt;/pre&gt;

&lt;h1&gt; Vim 이란? &lt;/h1&gt;

&lt;p&gt;Vim 은 에디터입니다. CLI (Command Line Interface) 환경에서 쓰는 에디터라 GUI (Graphical User Interface) 에 익숙한 사람은 (저같은 사람 포함) 어렵게 느껴집니다. 그래서 인지 몰라도 Sublime Text 라던가, 이와 비슷한 에디터를 사용하는 경우가 많죠. 저도 Sublime Text를 사용중 입니다.&lt;/p&gt;

&lt;h1&gt; Vim의 필요성 &lt;/h1&gt;

&lt;p&gt;하지만, Vim 이 필요한 경우가 있을 수 있습니다. 특히 현업에서, 서버를 만지는 작업을 하게 되면 기본적인 것을 알아야 하는 경우가 있습니다. 대표적인 이유로는, UNIX 계열 기반의 서버에서 기본적으로 설치되어 있기 때문입니다. 예를들어, 남의 서버를 troubleshooting을 하게 되면, ssh로 들어가서 하는 경우도 있는데, 이 경우에는 vim 밖에 설치 되어있지 않은 경우가 있고 이때는 어쩔수 없이 Vim을 써야되기 때문입니다.&lt;/p&gt;

&lt;p&gt;다른 이유도 있겠지만 저에게 있어서는 가장 중요한 이유이네요.&lt;/p&gt;</content><author><name></name></author><category term="general" /><summary type="html">이 페이지는 지원되는 모든 언어로 번역되어 있습니다.</summary></entry><entry><title type="html">Introduction to Common Gateway Interface (CGI)</title><link href="/ko/posts/general/cgi" rel="alternate" type="text/html" title="Introduction to Common Gateway Interface (CGI)" /><published>2017-05-01T00:00:00+10:00</published><updated>2017-05-01T00:00:00+10:00</updated><id>http://localhost:4000/posts/general/cgi</id><content type="html" xml:base="http://localhost:4000/posts/general/cgi">&lt;blockquote&gt; The following post is written based on LAMP (Linux / Apache / MySQL / PHP) tech stack. &lt;/blockquote&gt;

&lt;pre&gt; &lt;b&gt; 이 페이지는 지원되는 모든 언어로 번역되어 있습니다.&lt;/b&gt; &lt;/pre&gt;

&lt;h1&gt; Background &lt;/h1&gt;

&lt;p&gt;When a user clicks on a hyperlink, the web browser first make a request to the HTTP server. This web server then process this request (e.g. URL)  and look for the file. Then, the web browser takes the response from the server and displays it.&lt;/p&gt;

&lt;p&gt;However, we can set up the server so that it executes a script when the web browser makes a request and then the browser displays the output of the script (or program). These scripts are called ‘CGI scripts’ and these can be in different languages such as Perl and Python.&lt;/p&gt;

&lt;h1&gt; Location of CGI scripts &lt;/h1&gt;

&lt;p&gt;CGI scripts to be executed by the HTTP server are kept in a pre-configured directory and this directory is usually named as ‘/cgi-bin.’&lt;/p&gt;

&lt;pre&gt; &lt;code&gt; PERL CGI files have the extension &lt;b&gt;.cgi&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt; Is CGI the best way? &lt;/h1&gt;

&lt;p&gt;In the case of LAMP stack, there are few ways to execute PHP scripts: 1) Apache module (mod_php) 2) CGI 3) FastCGI.&lt;/p&gt;

&lt;p&gt;The problem with CGI is that whenever a user loads a page, PHP will have to read &lt;code&gt;php.ini&lt;/code&gt; and set its settings, load all the extensions and start to parse the script. This is a lot of work. On the other hand, if a module is used, these steps are only done once. FastCGI with nginx also used to be very popular but it seems that php-fpm is now very popular since it sort of combines benefits of Apache (mod_php) and FastCGI.&lt;/p&gt;

&lt;p&gt;Therefore, CGI is a concept that should be understood but not to be use nowadays (although there may be a use case for it).&lt;/p&gt;</content><author><name></name></author><category term="general" /><summary type="html">The following post is written based on LAMP (Linux / Apache / MySQL / PHP) tech stack.</summary></entry><entry><title type="html">Git - Collaborating with others on GitHub</title><link href="/ko/posts/general/git-collaborate-on-github" rel="alternate" type="text/html" title="Git - Collaborating with others on GitHub" /><published>2017-04-20T00:00:00+10:00</published><updated>2017-04-20T00:00:00+10:00</updated><id>http://localhost:4000/posts/general/git-collaborate-on-github</id><content type="html" xml:base="http://localhost:4000/posts/general/git-collaborate-on-github">&lt;p&gt;나만의 프로젝트만이 아니라 남의 프로젝트에 참여할 경우가 있을 것이다. 예를들어 내가 만든 Jekyll Theme인 Console은 현재 Contributor 가 3명이 있다. 내 프로젝트에 다른 2명이 코드를 고치거나 추가한 셈인데, 이것이 어떻게 이루어 지는지에 대해 설명하도록 하겠다.&lt;/p&gt;

&lt;h1&gt; Step 1. Forking &lt;/h1&gt;

&lt;p&gt;그렇다. 우리가 알고 있는 포크의 그 fork이다. 하지만 Git에서는 forking이라 하면, 참여하고자 하는 프로젝트를 clone (복제) 하여 나의 GitHub account에 이 복제품을 repository로 만들고자 하는 작업이다. 그러면 이 복제된 repository에서 개발자는 작업을 시작하게 된다. 물론 이 fork 된 repository는 이 repository의 원 repository에 대한 정보를 알고 있다.&lt;/p&gt;

&lt;h1&gt; Step 2. Making a pull request &lt;/h1&gt;

&lt;p&gt;Pull request는 말 그대로, pull 좀 해달라고 요청 (request) 하는 것이다. 내가 작업한 commit들을 실제 repository에 merge 해야 하는데, 이 경우 실제 주인 허락 없이는 merge를 할 수 없고, commit 대신 pull request를 보내서 실제 repository 의 주인이 허락을 하면 그 commit이 실제 repository에 merge 되는 것이다. 이렇게 다른 사람의 프로젝트에 참여할 수 있다.&lt;/p&gt;

&lt;p&gt;보통 &lt;b&gt;Contributing&lt;/b&gt; 이라는 제목으로 README.md 에 대부분 어떻게 참여하는지 방법들이 나와있지만, 기본적으로 저 2개의 스텝을 따를 것이다.&lt;/p&gt;</content><author><name></name></author><category term="general" /><summary type="html">나만의 프로젝트만이 아니라 남의 프로젝트에 참여할 경우가 있을 것이다. 예를들어 내가 만든 Jekyll Theme인 Console은 현재 Contributor 가 3명이 있다. 내 프로젝트에 다른 2명이 코드를 고치거나 추가한 셈인데, 이것이 어떻게 이루어 지는지에 대해 설명하도록 하겠다.</summary></entry><entry><title type="html">호주 이민에 대한 나의 생각</title><link href="/ko/posts/travel/about-aus-immi" rel="alternate" type="text/html" title="호주 이민에 대한 나의 생각" /><published>2017-04-20T00:00:00+10:00</published><updated>2017-04-20T00:00:00+10:00</updated><id>http://localhost:4000/posts/travel/about-aus-immi</id><content type="html" xml:base="http://localhost:4000/posts/travel/about-aus-immi">&lt;h1&gt; 나의 이민 과정 &lt;/h1&gt;

&lt;p&gt;벌써 호주로 이민온지도 8개월정도 지나가고 있다. 본인은 소위 189/190 기술이민 비자 제도를 통해 2016년 7월 4일 (정확히 말해서 새로 호주 회계년도가 시작되는 날!) 에 visa grant 가 나왔었고, 그리고 1개월 후 호주에 입국하게된 케이스이다. 사실 더 일찍 나오는 것을 예상하였으나, 그 시절 2016년 3월부터 엄청나게 경쟁이 심해져서 당연히 60점으로는 부족하기 때문에 65점으로 지원하였고, 모든 영주권 프로세스가 약 8개월이 걸린 듯하다.&lt;/p&gt;

&lt;h1&gt; 현재 이민 동향에 대해 &lt;/h1&gt;

&lt;p&gt;현재 8개월이 지나가는 시점, 턴불 정부에서 457비자 폐지 소식이 들리더니 시민권 조건 강화 이야기가 나온다. 사실 2011년 7월 1일부터 길라드 총리가 시작한 점수제 부터 강화가 사실상 된 셈이었고, 드디어 오늘 정점을 찍은 것 같다. 그렇다면 이렇게 강화하는데, 과연 이렇게 어려운 과정 (정확히 얘기해서 영주권을 기술이민으로 획득 후, 시민권을 취득하는 것) 을 거치는 것이, 나에게 그에 부합한 많은 이익을 가져다 주는가? 생각해 볼때, 몇가지 생각을 적고자 한다.&lt;/p&gt;

&lt;h3&gt; 호주 시민권의 장점 &lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt; &lt;b&gt;더이상 영주권을 연장할 필요가 없다&lt;/b&gt;: 영주권을 연장할려면 RRV 라는 것을 신청해야 하는데 이것도 돈이다. 그렇기 때문에 돈을 낼 필요도 없으며, 5년 중에 2년을 살아야 되는 조건도 없으므로 자유가 된다. 이 부분에 대해서는 정말 중요한데, 본인은 다른 나라에 또 갈 의사가 있기 때문에 이 부분은 정말 중요하게 생각한다.&lt;/li&gt;
  &lt;li&gt; &lt;b&gt;미국에서 취업할 경우 H1B 비자가 아닌 E3 비자를 신청할 수 있다&lt;/b&gt;: 미호 (AUS-USA) FTA를 통해서 호주인은 H1B 대신 E3비자로 미국에서 살 수 있다. 요즘 H1B도 트럼프 정부 이후로 강화하는 것으로 볼때 본인에게 있어서 E3 비자의 옵션은 충분히 매력으로 다가온다.&lt;/li&gt;
  &lt;li&gt; &lt;b&gt;특정 호주 내에서 직업들은 시민권을 필요로 한다&lt;/b&gt;: 정부 관련 직업들은 security clearance가 필요하므로 이런 잡은 시민권을 필요로 한다. 그렇기 때문에 이 것을 충족하기 위해서는 시민권이 필요하므로 장점이 될 수 있다.&lt;/li&gt;
  &lt;li&gt; &lt;b&gt;리사본 조약 가입국가 시민&lt;/b&gt;: 이 부분은 잘 모를 수 있는데, 유럽에서 필요로 할 때가 있다. 예를들어 입학 시험 면제의 경우 이 가입국가 학부 출신들은 면제가 되는 경우도 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt; 호주 시민권의 단점 &lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt; &lt;b&gt;한국 국적을 포기해야 한다&lt;/b&gt;: 이미 국방의 의무를 마치고 4대 의무를 마친 사람으로서는, 사실 이 부분은 많이 아쉽다. 아직 후천적으로 비-대한민국 시민권을 취득할 경우 복수국적이 허용이 안되기 때문에 2020년까지 법이 바뀌지 않는 한 포기해야 한다. 하지만 재외동포비자 그리고 다시 귀화가 어렵지 않다는 것이 있어서 크게 문제가 되지는 않겠다고 생각하고 있다. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;종합적으로 봤을 때, 나에게 있어서는 아직까지는 호주 시민권이 어려워 진다해도 도움이 되므로 충분히 도전해 볼만하다. 어려워도 영주권 프로세스 보단 복잡하지 않으니까.&lt;/p&gt;

&lt;h1&gt; 이민이 어려워 지는 것에 대해 &lt;/h1&gt;

&lt;p&gt;사실 본인은 이미 영주권을 취득하였고 더이상 생각할 필요가 없다. 시민권이 강화 된다 하더라도 말이다. 하지만 어려워지는 것은 기본적으로 ‘호주 사회에 제대로 동화 하는 것’ 을 전제로 하는 것 같다. 그렇다면 이 전제 (assumption) 을 받아 들인다면, 현재 움직임은 전혀 이상하지 않다고 생각한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt; &lt;b&gt;호주 사회에서 잘 살려면 영어는 기본이다&lt;/b&gt;: 본인이 이민을 하였을 때는 IELTS 점수가 8.5 (9.0 만점) 였다. 그래도 회사에서 100% 자유롭게 대화할 수 있나? 그건 아니다. 물론 일적인 얘기는 100% 가능하다고 생각하지만 일상적인 얘기는 가끔 못 알아 들을 때도 있기 때문이다 (호주 억양도 한 몫하는 것 같다). 하지만, 영어가 안된다면, 못 알아 듣는 것이 쉽게 나아지지는 않을 것이라 생각한다.&lt;/li&gt;
  &lt;li&gt; &lt;b&gt;호주에서 제대로 취업하려면 호주인보다 좋은 스펙이 당연히 유리하다&lt;/b&gt;: 만약 스펙이 소위 '백인' 호주인과 똑같다면 문화가 똑같은 '백인'을 채용하려 할 것이다. 그렇기 때문에 정말 더 좋은 스펙이 있어야 한다고 아직도 생각한다. 그렇기 때문에 예를들어 3년 경력이 점수제에서 5점을 추가로 준다는 것은 그만틈 그정도 경력이 있어야 호주에서 취업할 수 있는 가능성이 높다는 뜻이다. 본인은 경력이 1년밖에 없어서 그렇게 많은 회사에서 연락오지는 않았다. 10개를 넣었다면 실제 연락오는 곳은 4곳, 그리고 최종 오퍼로 연결된 것은 2곳이었다. &lt;/li&gt;
  &lt;li&gt; &lt;b&gt;이민은 어렵다&lt;/b&gt;: 학부시절 3년 정도 호주에 살아도 이민을 오니 막상 다르다. 렌트할 집을 찾고, 좋은 연봉을 주는 회사를 찾아야 하고, 차도 사고 등등, 완전히 유학생 때의 나와 다른 삶을 살게 된다. 필자는 다행이도, 위의 모든 것을 갖추는데 2개월 정도 걸렸지만, 일반적으로 더 오래 걸리는 경우가 적지 않다. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇기 때문에 어려워 져도, 생각하는 것이 “ 저 조건들을 맞춘다면 그나마 수월하게 제대로 정착할 수 있을 것 같다. “ 라는 생각을 했다. 너무 부정적으로만 보지 말고, 긍정적으로 보는 것이 중요하고, 치밀하게 준비하는 것이 더 정신건강에 좋다고 생각한다.&lt;/p&gt;</content><author><name></name></author><category term="travel" /><summary type="html">나의 이민 과정</summary></entry><entry><title type="html">Git - changing branch - as simple as checkout?</title><link href="/ko/posts/general/git-changing-branch" rel="alternate" type="text/html" title="Git - changing branch - as simple as checkout?" /><published>2017-04-18T00:00:00+10:00</published><updated>2017-04-18T00:00:00+10:00</updated><id>http://localhost:4000/posts/general/git-changing-branch</id><content type="html" xml:base="http://localhost:4000/posts/general/git-changing-branch">&lt;p&gt;지난 번 branch 의 타입에 대해서 알아 봤는데, 사실 실제 협업 환경에서는 그렇게 branch를 옮기는 작업이 쉽지 않다. 예를들어 내가 어떤 branch에 작업하고 있었는데 이 것을 commit 하지 않고 다른 branch로 간다고 상상해 보자, 이 경우 내가 작업 했던 내용이 다른 branch 로 건너가게 된다. 이 경우, 가장 ideal 한 경우는 tracked / untracked (이 부분은 아직까지 알아보지 않았지만, 간단히 얘기해서 Git 이 버젼 관리를 하는 파일이 있을 수 있고 관리 하지 않는 파일이 있을 수 있는데, 나중에 알아보겠지만, .gitignore 파일에 관리 하지 않는 파일을 정의하면 Git은 이 파일들을 관리하지 않게 된다) 둘다 commit을 하던지, 어떻게든 해결하고 다른 branch로 이동하는 것이다. 이 경우 Git 에서는 stash 라는 개념이 있다.&lt;/p&gt;

&lt;h1&gt; Stash 란 ? &lt;/h1&gt;

&lt;p&gt;어떤 저장장소라고 생각해 보면 좋겠다. 내가 다른 branch 로 가고 싶은데 가기 전에 변경 사항들을 stash라는 저장장소에 넣어 두고 나중에 다시 돌아와서 다시 그 변경 사항들을 적용하는 방법이다. 가끔 엄청 유용할 때가 있다. 그리고 사용법도 기본적으로는 무척 간단하다. 다른 branch 로 옮기기 전:&lt;/p&gt;

&lt;pre&gt;
  &lt;code&gt; git stash [stash 이름] &lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;그리고 나중에 간단하게&lt;/p&gt;

&lt;pre&gt;
  &lt;code&gt; git stash apply &lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;를 통해서 다시 적용하면 된다.&lt;/p&gt;

&lt;p&gt;일단 Stashing 은 이정도로 해두도록 하자. 만약, 더 자세하게 관심이 있다면, 추후에 나올 Git Advanced Stashing 을 참고해 주시길.&lt;/p&gt;</content><author><name></name></author><category term="general" /><summary type="html">지난 번 branch 의 타입에 대해서 알아 봤는데, 사실 실제 협업 환경에서는 그렇게 branch를 옮기는 작업이 쉽지 않다. 예를들어 내가 어떤 branch에 작업하고 있었는데 이 것을 commit 하지 않고 다른 branch로 간다고 상상해 보자, 이 경우 내가 작업 했던 내용이 다른 branch 로 건너가게 된다. 이 경우, 가장 ideal 한 경우는 tracked / untracked (이 부분은 아직까지 알아보지 않았지만, 간단히 얘기해서 Git 이 버젼 관리를 하는 파일이 있을 수 있고 관리 하지 않는 파일이 있을 수 있는데, 나중에 알아보겠지만, .gitignore 파일에 관리 하지 않는 파일을 정의하면 Git은 이 파일들을 관리하지 않게 된다) 둘다 commit을 하던지, 어떻게든 해결하고 다른 branch로 이동하는 것이다. 이 경우 Git 에서는 stash 라는 개념이 있다.</summary></entry></feed>